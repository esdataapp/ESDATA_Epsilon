# 🏗️ ARQUITECTURA TÉCNICA - Dashboard ZMG

## 📊 **MODELO DE DATOS DETALLADO**

### Base de Datos Principal (PostgreSQL + PostGIS)

#### 1. Tabla `listings_processed`
```sql
CREATE TABLE listings_processed (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    external_id VARCHAR(100) UNIQUE,
    created_at TIMESTAMP DEFAULT NOW(),
    
    -- Clasificación
    operation VARCHAR(20) NOT NULL, -- 'venta', 'renta', 'remate'
    property_type VARCHAR(30) NOT NULL, -- 'departamento', 'casa', etc.
    
    -- Ubicación
    city VARCHAR(50) NOT NULL,
    municipality VARCHAR(50) NOT NULL,
    colony VARCHAR(100),
    location POINT, -- PostGIS geometry
    
    -- Características físicas
    price DECIMAL(12,2) NOT NULL,
    surface_built_m2 DECIMAL(8,2),
    price_per_sqm DECIMAL(10,2) GENERATED ALWAYS AS (
        CASE WHEN surface_built_m2 > 0 THEN price / surface_built_m2 ELSE NULL END
    ) STORED,
    
    -- Habitabilidad
    bedrooms INTEGER,
    bathrooms DECIMAL(3,1),
    parking_spots INTEGER DEFAULT 0,
    
    -- Amenidades
    amenities JSONB DEFAULT '[]'::jsonb,
    
    -- Análisis
    is_outlier BOOLEAN DEFAULT FALSE,
    price_stratum VARCHAR(20),
    market_segment VARCHAR(50),
    
    CONSTRAINT valid_price CHECK (price > 0)
);

-- Índices para performance
CREATE INDEX idx_listings_location ON listings_processed USING GIST (location);
CREATE INDEX idx_listings_filters ON listings_processed (operation, property_type, city);
CREATE INDEX idx_listings_amenities ON listings_processed USING GIN (amenities);
```

#### 2. Tabla `market_stats` (Agregaciones)
```sql
CREATE TABLE market_stats (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    
    -- Dimensiones
    geo_level VARCHAR(20) NOT NULL,
    geo_id VARCHAR(100) NOT NULL,
    property_type VARCHAR(30),
    operation VARCHAR(20),
    
    -- Conteos
    count_total INTEGER NOT NULL DEFAULT 0,
    count_outliers INTEGER DEFAULT 0,
    
    -- Estadísticos de PRECIO
    price_mean DECIMAL(12,2),
    price_median DECIMAL(12,2),
    price_p25 DECIMAL(12,2),
    price_p75 DECIMAL(12,2),
    price_std DECIMAL(12,2),
    
    -- Estadísticos de SUPERFICIE
    surface_median DECIMAL(8,2),
    surface_p25 DECIMAL(8,2),
    surface_p75 DECIMAL(8,2),
    
    -- Estadísticos de PRECIO POR M²
    pxm2_median DECIMAL(10,2),
    pxm2_p25 DECIMAL(10,2),
    pxm2_p75 DECIMAL(10,2),
    
    -- Métricas de mercado
    price_appreciation_30d DECIMAL(6,4),
    
    calculation_date TIMESTAMP DEFAULT NOW(),
    
    UNIQUE(geo_level, geo_id, property_type, operation)
);
```

---

## 🔌 **ENDPOINTS API PRINCIPALES**

### 1. Overview y KPIs - `GET /api/stats/overview`
```typescript
interface OverviewResponse {
  meta: {
    last_update: string;
    cached: boolean;
  };
  data: {
    total_properties: number;
    avg_price: number;
    median_price: number;
    price_change_30d: number;
    avg_pxm2: number;
    
    top_colonies: Array<{
      name: string;
      municipality: string;
      count: number;
      avg_pxm2: number;
      change_30d: number;
    }>;
    
    insights: Array<{
      type: 'trend' | 'opportunity' | 'alert';
      title: string;
      description: string;
      impact: 'high' | 'medium' | 'low';
    }>;
    
    price_distribution: Array<{
      range: string;
      count: number;
      percentage: number;
    }>;
  };
}
```

### 2. Filtros - `POST /api/stats/filtered`
```typescript
interface FilterRequest {
  property_type?: string[];
  operation?: string[];
  price_range?: [number, number];
  surface_range?: [number, number];
  colonies?: string[];
  bedrooms?: number[];
  bathrooms?: number[];
  amenities_required?: string[];
  include_outliers?: boolean;
}

interface FilteredResponse {
  meta: {
    total_matches: number;
    execution_time_ms: number;
  };
  stats: {
    count: number;
    price: StatsSummary;
    surface: StatsSummary;
    pxm2: StatsSummary;
    by_colony: Array<ColonyStats>;
  };
}
```

### 3. Mapa de Calor - `GET /api/geo/heatmap`
```typescript
interface HeatmapResponse {
  type: 'FeatureCollection';
  features: Array<{
    type: 'Feature';
    properties: {
      geo_id: string;
      name: string;
      value: number;
      percentile: number;
      color: string;
      count: number;
    };
    geometry: GeoJSON.MultiPolygon;
  }>;
  meta: {
    color_scale: Array<{value: number; color: string;}>;
    value_range: [number, number];
  };
}
```

---

## 🔄 **SISTEMA DE CACHE**

### Estrategia Multi-Nivel

#### Redis (Hot Data)
```typescript
const CACHE_STRATEGIES = {
  'overview': {
    ttl: 15 * 60, // 15 minutos
    key_pattern: 'stats:overview'
  },
  'filtered_stats': {
    ttl: 5 * 60, // 5 minutos
    key_pattern: 'stats:filtered:{hash}'
  },
  'correlations': {
    ttl: 30 * 60, // 30 minutos
    key_pattern: 'corr:{segment_hash}'
  }
};
```

#### Materialized Views
```sql
CREATE MATERIALIZED VIEW mv_colony_stats AS
SELECT 
    colony,
    municipality,
    property_type,
    COUNT(*) as count,
    AVG(price) as avg_price,
    PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY price) as median_price,
    AVG(price_per_sqm) as avg_pxm2
FROM listings_processed 
WHERE is_outlier = FALSE
GROUP BY colony, municipality, property_type;
```

---

## 📊 **INTEGRACIÓN CON PIPELINE PYTHON**

### Script de Sincronización
```python
# dashboard/sync_data.py
import pandas as pd
from sqlalchemy import create_engine
from datetime import datetime

class DashboardDataSync:
    def __init__(self, db_url: str):
        self.engine = create_engine(db_url)
    
    def sync_processed_listings(self, csv_path: str):
        """Sincroniza datos del pipeline principal"""
        df = pd.read_csv(csv_path)
        df = self.prepare_listings_data(df)
        df.to_sql('listings_processed', self.engine, 
                 if_exists='replace', index=False)
        print(f"Sincronizados {len(df)} listings")
    
    def calculate_market_stats(self):
        """Calcula estadísticas agregadas"""
        # Implementar cálculos por colonia, tipo, etc.
        pass
    
    def calculate_correlations(self):
        """Calcula matrices de correlación"""
        # Implementar análisis de correlaciones
        pass
```

---

## 🚀 **CONFIGURACIÓN DE DESARROLLO**

### Docker Compose
```yaml
version: '3.8'
services:
  postgres:
    image: postgis/postgis:15-3.3
    environment:
      POSTGRES_DB: dashboard_zmg
      POSTGRES_USER: dashboard
      POSTGRES_PASSWORD: ${DB_PASSWORD}
    ports:
      - "5432:5432"
    volumes:
      - postgres_data:/var/lib/postgresql/data
  
  redis:
    image: redis:7-alpine
    ports:
      - "6379:6379"
  
  backend:
    build: ./backend
    ports:
      - "3001:3001"
    environment:
      DATABASE_URL: postgresql://dashboard:${DB_PASSWORD}@postgres:5432/dashboard_zmg
      REDIS_URL: redis://redis:6379
    depends_on:
      - postgres
      - redis
  
  frontend:
    build: ./frontend
    ports:
      - "5173:5173"
    depends_on:
      - backend

volumes:
  postgres_data:
```

### Variables de Entorno
```env
# Database
DATABASE_URL=postgresql://dashboard:password@localhost:5432/dashboard_zmg
REDIS_URL=redis://localhost:6379

# API
API_PORT=3001
API_BASE_URL=http://localhost:3001

# Mapbox
VITE_MAPBOX_TOKEN=your_mapbox_token_here

# Cache
CACHE_TTL_OVERVIEW=900
CACHE_TTL_FILTERED=300
CACHE_TTL_CORRELATIONS=1800
```

---

## 📱 **ESTRUCTURA FRONTEND**

### Organización de Archivos
```
frontend/
├── src/
│   ├── components/
│   │   ├── ui/              # shadcn/ui components
│   │   ├── charts/          # Chart wrappers
│   │   ├── maps/            # Map components
│   │   └── filters/         # Filter components
│   ├── pages/
│   │   ├── Inicio.tsx       # Overview/KPIs
│   │   ├── Explorar.tsx     # Map + exploration
│   │   ├── Segmentos.tsx    # Segmentation
│   │   └── Analitica.tsx    # Advanced analytics
│   ├── hooks/
│   │   ├── useFilters.ts    # Filter management
│   │   ├── useStats.ts      # Data fetching
│   │   └── useDebounce.ts   # Performance
│   ├── store/
│   │   └── dashboardStore.ts # Zustand store
│   ├── utils/
│   │   ├── formatters.ts    # Number/currency formatting
│   │   └── constants.ts     # App constants
│   └── types/
│       ├── api.ts           # API response types
│       └── filters.ts       # Filter types
├── package.json
└── vite.config.ts
```

### Configuración de Vite
```typescript
// vite.config.ts
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'
import path from 'path'

export default defineConfig({
  plugins: [react()],
  resolve: {
    alias: {
      "@": path.resolve(__dirname, "./src"),
    },
  },
  server: {
    proxy: {
      '/api': {
        target: 'http://localhost:3001',
        changeOrigin: true
      }
    }
  }
})
```

---

## 🔧 **CONFIGURACIÓN BACKEND**

### NestJS Main Module
```typescript
// app.module.ts
import { Module } from '@nestjs/common';
import { PrismaModule } from './prisma/prisma.module';
import { StatsModule } from './stats/stats.module';
import { GeoModule } from './geo/geo.module';
import { AnalysisModule } from './analysis/analysis.module';
import { CacheModule } from '@nestjs/cache-manager';
import { redisStore } from 'cache-manager-redis-store';

@Module({
  imports: [
    PrismaModule,
    StatsModule,
    GeoModule,
    AnalysisModule,
    CacheModule.register({
      store: redisStore,
      host: process.env.REDIS_HOST || 'localhost',
      port: parseInt(process.env.REDIS_PORT) || 6379,
      ttl: 300, // 5 minutes default
    }),
  ],
})
export class AppModule {}
```

### Prisma Schema
```prisma
// schema.prisma
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model ListingProcessed {
  id            String   @id @default(cuid())
  externalId    String?  @unique @map("external_id")
  createdAt     DateTime @default(now()) @map("created_at")
  
  operation     String
  propertyType  String   @map("property_type")
  city          String
  municipality  String
  colony        String?
  
  price         Decimal  @db.Decimal(12, 2)
  surfaceM2     Decimal? @map("surface_built_m2") @db.Decimal(8, 2)
  pricePerSqm   Decimal? @map("price_per_sqm") @db.Decimal(10, 2)
  
  bedrooms      Int?
  bathrooms     Decimal? @db.Decimal(3, 1)
  parkingSpots  Int?     @default(0) @map("parking_spots")
  
  amenities     Json     @default("[]")
  
  isOutlier     Boolean  @default(false) @map("is_outlier")
  priceStratum  String?  @map("price_stratum")
  
  @@map("listings_processed")
}

model MarketStats {
  id           String   @id @default(cuid())
  geoLevel     String   @map("geo_level")
  geoId        String   @map("geo_id")
  propertyType String?  @map("property_type")
  operation    String?
  
  countTotal   Int      @default(0) @map("count_total")
  priceMedian  Decimal? @map("price_median") @db.Decimal(12, 2)
  pxm2Median   Decimal? @map("pxm2_median") @db.Decimal(10, 2)
  
  calculatedAt DateTime @default(now()) @map("calculated_at")
  
  @@unique([geoLevel, geoId, propertyType, operation])
  @@map("market_stats")
}
```

---

Este documento proporciona la base técnica completa para implementar el dashboard. ¿Te gustaría que continúe con alguna sección específica o que comience con la implementación práctica?
